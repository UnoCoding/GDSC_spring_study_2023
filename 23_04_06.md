
code_contents
# Spring DB 접근 기술 #
> * H2 데이터 베이스 설치
> * 순수 JDBC
> * 스프링 통합 테스트
> 
# 1. H2 데이터 베이스 설치
<p> h2란? 개발이나 테스트 용도로 사용하는 DB, 가볍고 편리하면 웹 화면 제공 </p>
<a href="https://www.h2database.com/html/download-archive.html">설치 링크</a>, 1.4.200 버전 설치 <br>

터미널에서 `h2/bin` 이동 후 ` ./h2.sh ` 커맨드 입력 그럼 다음과 같은 창이 자동으로 뜬다.
<img width="1552" alt="Screen Shot 2023-04-05 at 7 40 41 PM" src="https://user-images.githubusercontent.com/87971454/230057649-c9fe85db-152b-44fd-b530-19b484218fe7.png"><br>
`JDBC URL` 칸에 에 `jdbc:h2:~/test` 입력 후   `~/test.mv.d` 파일 생성 되었는지 확인.<br>
<img width="558" alt="Screen Shot 2023-04-05 at 7 43 12 PM" src="https://user-images.githubusercontent.com/87971454/230058170-71e029c8-0ff2-48ae-a344-7dbb299393e2.png"><br>
그 이후로 부터는 `JDBC URL`에 `jdbc:h2:tcp://localhost/~/test` 입력 후 접속하면 다음과 같은 화면이 뜸.<br>
<img width="1552" alt="Screen Shot 2023-04-05 at 7 44 34 PM" src="https://user-images.githubusercontent.com/87971454/230058470-8b0b2411-44de-4eed-85fc-f1394aa6fffe.png"><br>
콘솔에 다음과 같이 입력
<pre>
drop table if exists member CASCADE;
    create table member
    (
        id   bigint generated by default as identity,
        name varchar(255),
        primary key (id)
);
</pre>
`MEMBER`테이블이 생성된 것을 확인
<img style='display:block,margin:auto' width="440" alt="Screen Shot 2023-04-05 at 7 46 19 PM" src="https://user-images.githubusercontent.com/87971454/230058828-fe20d39a-a9fa-4f59-92b7-4f3fb0ec631c.png"><br>
`insert into MEMBER(name) values("spring1");` <br>입력 후 테이블 확인<br>
<img width="527" style='display:block,margin:auto' alt="Screen Shot 2023-04-05 at 7 53 41 PM" src="https://user-images.githubusercontent.com/87971454/230060302-76505d9b-2e7d-40f0-9da9-ddaa69f43ae2.png">
테이블에 작성한 쿼리가 입력되었다는 것을 알 수 있다. `ID` 값은 입력해주지 않았지만 자동으로 1로 들어갔음을 알 수 있다. 그 이유는 테이블 작성시 `id` 속성에 `generated by default as identity`라는 속성을 넣어줬기 때문이다. <br>
# 2. 순수 JDBC
> 환경 설정

`build.gradle` 파일에 `jdbc`, `h2` 데이터베이스 관련 라이브러리 추가.<br>
```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    runtimeOnly('com.h2database:h2:')
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
이후 `application.properties` 에서 스프링부트 데이터베이스 연결 설정 추가
```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```
그 후 `repository` 디렉토리에 `JdbcMemberRepository` 생성 후 다음과 같은 코드 복사 붙여 넣기하자. ( 지금 배우는 스타일은 너무 구식이여서 직적 따라칠 필요가 없다. )
```java
package your_own_package_path;
import com.sung_1.firstproject.domain.Member;
import com.sung_1.firstproject.repository.MemberRepository;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;

    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)"; //Db에 넣어줄 쿼리문
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName()); //?에 name을 mapping 시켜준다.
            pstmt.executeUpdate(); //Db에 실제 데이터 쿼리가 날아감
            rs = pstmt.getGeneratedKeys(); //id를 꺼내줌
            if (rs.next()) { //값이 있으면 값을 꺼내주고,
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패"); // 없으면 exception handling
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;

        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();

            List<Member> members = new ArrayList<>();
            while (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public void storeClear() {

    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }

            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }

    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);

    }
}

```
`SpringConfig` 파일로 가서 `JdbcMemberRepository`를 위한 자바빈을 생성하기 위해 코드 추가.
```java
package com.sung_1.firstproject.service;


import com.sung_1.firstproject.repository.JdbcMemberRepository;
import com.sung_1.firstproject.repository.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {
    private DataSource dataSource;   //추가한 코드
@Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }                                //추가한 코드

    @Bean
    public MemberService memberService(){
        return new MemberService(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository(){
        return new JdbcMemberRepository(dataSource); //수정한 코드
    }
}

```
코드 실행후 `localhost:8080`로 접속 후 회원 조회하면 다음과 같이 정상적으로 db에 있는 데이터들을 가져온다.<br> <img width="527" alt="Screen Shot 2023-04-05 at 8 48 59 PM" src="https://user-images.githubusercontent.com/87971454/230071686-3a6ab4e5-6ade-448b-b149-6286cc35d306.png"> <br><페이지에 띄어지는 화면><br>
<img width="527" alt="Screen Shot 2023-04-05 at 8 49 09 PM" src="https://user-images.githubusercontent.com/87971454/230071790-4a756a6d-6a4e-4c51-8359-8827ac47c462.png"> <br> <웹 콘솔에 띄어지는 화면> <br>
 `localhost:8080' 에서 멤버를 추가해도 정상적으로 수행된다.<br>
 * `MemeberService`는 `MemberRepository`를 의존하고있다. *
 * `MemberRepository`는 구현체로 `MemmoryMemberRepository`와 `JdbcMemberRepository`를 가지고 있다.
<img width="907" alt="Screen Shot 2023-04-05 at 8 53 19 PM" src="https://user-images.githubusercontent.com/87971454/230072610-f4da14a1-218f-40d7-b344-355408ae69b1.png"><br>
<img width="907" alt="Screen Shot 2023-04-05 at 8 56 14 PM" src="https://user-images.githubusercontent.com/87971454/230073276-8e70e729-b882-4c51-8c43-7705bfeda808.png"><br>
* 스프링 컨테이너에서는 `<memory>MemberRepository` 를 수정하여 `<jdbc>MemberRepository`를 등록하였다.
* 나머지는 수정한 곳이 없다. -> 설정만으로도 구현 클래스를 변경할 수 있다.
* 개방-폐쇄 법칙(OCP, open-closed-princple) - 확장에는 열려있고 수정에는 닫혀있다. 
* -> 객체지향의 다형성의 개념을 잘 활용하면 기능을 완전히 변경해도, 어플리케이션 "전체"를 수정할 필요가 없다. 





